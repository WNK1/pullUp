//////////////////////////////////////////////////////////////////
/* Объекты в js - что это и что они из себя представляют  */
//объекты можно обозначить 2 способами 
let userqweqwqeData= new Object; //создание с помощью синтаксиса объекта
let userqweqwenfo = {}; // создание с помощью так называемого литерала объекта // 90% случаев гораздо более удобнее использовать этот способ 


//свойства объектов = ключ + значение 


let first="1";
let userCountry = {
    name:"Russia",                      //1 значение называется именем объекта или же его свойством 
    continent:"Eurasia", 
    eyars:"ochMnogo",                   //последняя запятай называется висячей и желательно ее использовать так как быстро можно будет что то поменять в объекте 
    "Russia federation":"My Country",    //паравильное написание пременной-ключа состоящего из 2 и более слов
    [first]:true,                      //передача имени в объект - то есть можем использовать внешнюю переменную

};

console.log(userCountry);                       // вызов всего объекта и показ всех данных которые в нем хранятся 
console.log(userCountry.continent);
console.log(userCountry["Russia federation"]); //правила ввыыедения в косносль если имя-ключ 2 и более слов
console.log(userCountry[first]);               //выведение переданной в объект переменной 


// преимущество квадратных скобок в том что мы можем получать данные из объекта , например определить переменную хранящюю свойство в себе / пример:
let babidjon = "name";
console.log(userCountry[babidjon]) //через точку это невозможно сделать

const habibi = {
    for:"352",      //в обектах можно использовать все, даже зарезервированые обозначение , не как в переменных в которых это исключенно;
    let:"515",
    1:"для имеени в объектах можно использовать даже числа"

}
console.log(habibi.let)
console.log(habibi[1])//только по фактам 1 это будет срока и ее можно выводить с "" :
console.log(habibi["1"]) //хоть так хоть так 

//Символ -спец обозначение которое как бы скрывается от циклов и тд и оно там не появится 
//создание символа :
let gg=Symbol("gg");
let hh ={
    jj:"не символ",
    [gg]:"А вот это символ",
}
console.log(hh)
console.log("Переход к новому термену");
//////////////////////////////////////
//так же в объектах есть вложенность 
const gorodaAdresa ={
    mem:"ъуъ",
    adress:{
        ylitsa:"kolotuska",
        dom:"2",
        kvartira:"неопределенно",
    }

}
console.log(gorodaAdresa);
console.log(gorodaAdresa.adress)
console.log(gorodaAdresa.adress.kvartira)
///////////////////////////////////////////
//добавление свойств-ключей-имен в объект 
let obk ={
    namet:'valorant',

}

console.log(obk);

obk.game="its a game";//

console.log(obk);

obk['time gameplay'] = '1k hour';
console.log(obk);

//если нам надо удаолить какое то свойство прописывем deleate - и оно бедет удаленно из объекта
delete obk.game;
console.log(obk)
//так же можем перезаписывать свойство объекта - всетак же прописываем путь до ключа который хотим изменить 
obk.namet = "frontend";
console.log(obk);

//копирование объекта - мы копируем так скажем не сам объект а его свойсво - то есть как бы просто ссылаемся на него ( был архив с папками и был ключ / мы копируем сам ключ но не архив)
let newObk=obk;
console.log(newObk);
newObk['time gameplay'] = "5k hour";
console.log(newObk);
console.log("истинный Obk");
console.log(obk)        ///при копировании данные так же изменяются ведь мы изменяем архив именно копируем , 
                        //а если мы хотим что бы один объект измениолся а другой остался изначальным то это уже называется дублированием 

//дублирование :
// Object.assign (куда(объект)-в какой объект в каоке место // что(1 свойство), что(2 свойство).... )
let dublObk = Object.assign({},obk)
dublObk.levl = "senior-pomidor";
dublObk['time gameplay'] = "4 eyars";
console.log(dublObk);
console.log("Отличия")
console.log(obk)

//Object.assign с помощью него можем добавлять новые свойства прямо со значением  
Object.assign(dublObk ,{ doxod:"420k в месяц" , gorod : { city:"Tyumen",car:"mercedes-benz"}});
console.log(dublObk);
//////////////////////////////////////////////////////








//тест на проверку существования того или иного значения :
if (dublObk.namet) {
console.log(dublObk.namet);                   ///////////////////////// почему не работае ?????????????????????????/
}










//проверка с помощью опциональной цепочки : главное что мы должны соблюдать такой синтаксис что бы у нас не загоралась красная ошибка если ключей нет это ?. ---
console.log(dublObk?.namet?.pc?.npc?.street)
//////////////////////////////////////////////
//проверка с помощью оператора in:
if("levl"/*имя пременной мы должны указывать независимо не от чего именно в "" */ in dublObk){
    console.log(dublObk.levl)
}  //если при проведение теста переменная не обнаружена то код не выводится вообще , не ошибки / абсолютно ничего

//когда использовать in в проверке ? тогда когда например у объекта в свойсвте как раз таки имеется значение undefinded -
/* let sdkfmsk ={ 
name = undefinded ;
ТОЛЬКО СВОЙСТВО IN ВЫВЕДЕТ В КОНСОЛЬ ЗНАЧЕНИЕ в других случаях код не выполниться / нельзя будет узнать что в name действительно есть занчение 
*/

console.log("for ..in цикл перебора данных !!!!!!!!!!!")
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//цикл For ... in используется для перебора значений 
for (let key /*key собирает все ключи - их значения в эту переменную*/ in dublObk){
    console.log(key) //выводит имена переменных 
    console.log(dublObk[key]) //а уже данный консоль лог выводит значения все переменных-ключей содержащихся в объекте
}
console.log("brrrrrrr");
for ( let key in dublObk.gorod){
    console.log(key);//ключи 
    console.log(dublObk.gorod[key])//значения ключей 
}



////////////////////////////
/* МЕТОДЫ ОБЪЕКТА */
//ФУНКЦИЯ ОБЪЕКТА ТАК ЖЕ МОЖЕТ БЫТЬ ПЕРЕМЕННОЙ //компанует все данные объекта в строчку 
let metod = {
    back :"2bb",
    alert:"в ахуе",
    holding :{
        countryaaa:"australia",
        director:"Nik Kud",

    },





    /*
    showInfosM: function (){
        console.log(`Состояние оценивается в ${this.back},все просто ${this.alert},Страна проживания на данный момент ${metod.holding.countryaaa} , имя:${metod.holding.director}`)


    }
    */
    //более которткая запись будет просто начинасться сразу объявления названия функции:
    //shouwRR(){
    //  console.log(`Состояние оценивается в ${this/*мы заменяем использование названия объекта из которого берется данные */.back},все просто ${this.alert},Страна проживания на данный момент ${metod/**/.holding.countryaaa} , имя:${metod/**/.holding.director}`)
   // }
//}
//metod.shouwRR();        //объявление функции все так же остается неизменным для ее выведения 








//не забываем про this - но нельзя его применять если есть еще одна вложеность функций ,так как this обращается к род элементу //=> НО у стрелочной функции нет своего this 
//и он будет все так же обращатся к главному род элементу ( использовать внешний род элемент) и все будет выводится без ошибши :

shouwRR(){
    let show = () => console.log(`Состояние оценивается в ${this.back},все просто ${this.alert},Страна проживания на данный момент ${this.holding.countryaaa} , имя:${this.holding.director}`);
    show();}
}
metod.shouwRR();
////////////////////////////////////
//МЕТОД THIS ГОРАЗДО НАДЕЖНЕЕ И НАДО ИСПОЛЬЗОВАТЬ ЕГО ТАК КАК ПРИ ДУБЛИРОВАНИИ ОБЪЕКТА МОГУТ БЫТЬ ОШИБКИ / НАПРИМЕР ПРИ ОБНУЛЕНИИ СТАРОГО ОБЪЕКТА СО СТАРЫМ НАЗВАНИЕМ
//let fhfh = oldfhfh ;
//oldfhfh =null;
//fhfh.showкк();  в консоле при этом будет выводиться ошибка 


//А ЕСЛИ БУДЕМ ИСПОЛЬЗОВАТЬ THIS У НАС КАК БЫ НЕТ ПРИВЯЗКИ К ОБЪЕКТУ
//ХОТЬ ОН КАК БУДТО БЫ И УДАЛЕН У НАС С THIS ВСЕ РАВНО ВСЕ БУДЕТ РАБОТАТЬ 


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//ФУНКЦИИ КОНСТРУКЦИИ - СЛУЖАТ ДЛЯ ОБЪЯВЛЕНИЯ МНОЖЕСТВА ОДНОТИПНЫХ ОБЪЕКТОВ 
//во превых имя функции должно начинаться с большой буквы ( что было точно понятно что эта функция конструктор )
//а так же функция конструктор должна вызываться при помощи оператора - new -

function CreateObj(namee,rabota){

    //this неявно создает новый/пусной объект
    this.namee = namee,
    this.age = 20,
    this.rabota = rabota;
    //дальше работает return this, возвращает объекты  опять таки неявно 
    

}
console.log(new CreateObj("Никита","мини-прогер"));
console.log(new CreateObj("Егор","прогер"))

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* тип данных числа */
/* 
метод toString - возвращает строковое значение и представляет числа в той или иной системе исчисления 




*/

const sys = 222 ;
console.log(sys.toString(32));
console.log(sys.toString(16));
console.log(sys.toString(8));
console.log(sys.toString(2));



/// операторы округления 
/* 

Math.floor - округляет все в меньшую сторону 

Math.ceil - округление в большую сторону 

Math.round - округление до ближайшего целого ;

*/ 
//ПРИМЕРЫ 

const floor = -2.2;
const ceil = 7.5;
const round = 5.443;

console.log(Math.floor(floor));
console.log(Math.ceil(ceil));
console.log(Math.round(round));

/* но есть одно но при помощи только данного оператора округления , операция может быть не точной 
пример что нам надо округлить число 8.465 до сотых , если применить оператор round то он округлит его все ранво до 9 
как это исправить ??? ----------------
--------   1 способ это применить умножение и деление ((Math.round(round)*100)/100)
*/
//////////////////////////////////////

console.log(Math.round((round*100))/100);
// 2 способ 
/* использовать оператор toFixed но при этом нужно помнить что опертор будет приобразовывать данные в строку , которую мы должны будем преобразовать обратно в числовое значение 

*/ 
const toFixed = 9.9499435;
console.log(+toFixed.toFixed(5));
//можно обратно преобразовать в число либо с помощью унароного оператора + 
console.log(Number(toFixed.toFixed(6)));
//либо же указать тип данных number соответственно 





// в js сущетвует проблема неточных вычсилений она решается либо прописанием достаточно большой и трудной  функции которая есть в документации js
// или же с помошью Number.epsilon(очень маленькие числа)
// пример 
const epsilon = 2.006434 + Number.epsilon ;
const eps = Math.round(epsilon * 100) / 100;
console.log(eps);


/// проверка значение isNaN и isFinite 
//сущетвует так как тот же самый NaN не буедт равен NaN и таких особенностей много 
console.log(Number(25 + "гаджишка делай"));
console.log(isNaN(25 + "гаджишка делай"));

//проверка Бесконечности 
console.log(isFinite(25)) //isfinite проверяет число и если оно обычное , то в консоль выводится true
console.log(isFinite("hi"));//так как это вообще строка выведится false 
console.log(isFinite(222/0));//бесконечность  соотвественно false

//если сталкиваться с числами у которых есть еденицы измерения например px то мы должны применять к ним функции 
//parsInt(целое число) & parsFloat (числа с плавуещей точкой)
 
const px = ('150.4561px');
console.log(parseInt(px));
console.log(parseFloat(px));

// функция math.random - возварщает случайные числа от 0 до 0.999999.... и тд
console.log(Math.random());



////
function brokenSite (){
    console.log(Math.random())
}

setTimeout (brokenSite ,);

////////////
//строки  
/* перевод строки можно делать либо с помощью экранирование ( привет \nКак у тебя дела ?\n) \n- спец символ для преноса 
   либо же просто с помощью обратный ковычек (` привет
                                                какой сегодня день недели ? `)

///////////////////                                              
    спец симовол табуляции \t добавит отступ , так скажем он сделает в строке отступ как это делае tab 
    \ - с помощью которого можно сделать так что бы спец символы по типу \ "" появлялись в тексте 
    так же в строки можно вставлять символы эмодзи utf16 , utf32   
*/

console.log( `привет , давно не виделись ✅`);

// что бы узнать длинну строки нам нужно прописать функцию .lenght
const lengt = "Hey yo bro , whats up hahaha!";
console.log(lengt.length);


//что бы получить символ из строки мы просто указываем его позиции 
//что бы получить первый символ мы ппрописываем :
console.log(lengt[0])

//что бы получить последний символ не зная на какой он позиции 
console.log(lengt[lengt.length - 1]);




//если мы хотим получать абсолютно все символы которые у нас есть в переменной и они появились в консоле то пропишем следущей цикл: for ..of 
for (const alfavit  /*---- /*переменная в которую будет записываться получаемое значение */ of lengt){
    console.log(alfavit);
}
//изминения регистра .toUpperCase - вся строка заглавными буквами 
//.toLowerCase - вся смтрока с маленькими буквами 
//если мы хотим найти совпадение в строке то мы используем функцию indexOf - она напм укажет позицию где начинается совпадение и есть ли оно вообще 
//если его не будет то в лог выведется -1 
console.log(lengt.indexOf('ts'));

//методы includes / startsWith / endsWith 
//  includes это более современный метод поиска совпадений в строке он выводит true / false в зависимости есть или же нет совпадений 

console.log(lengt.includes('ey'));//true
console.log(lengt.includes('ey', 7));//false - так как ey на 7 позиции нет 

//starsWith - ищет подстроку в начале 
//endsWith - соответственно ищет подстроку в конце 


//нужно помнить что регистр имеет значение 
//пример 
/* 
const gh - Year
const hg - yE 
то мы сначала должны привести нашу константу в нижний регистр так и что мы ищем и том числе к нижнему регистру 
console.log(gh.toLowerCase().includes(hg.toLowerCase()));
/*
*/
const gh = 'Year';
const hg = 'yE';

console.log(gh.toLowerCase().includes(hg.toLowerCase()));
//                ↑              ↑            ↑
//  1      соотвественно весь текс приводим в нижний регист       
//  2      начинаем поиск совпадений 
//  3      приводим то что мы пытаемся найти тоже в нижний регистр что бы небыло ошибок 


///////////////////////////////////
/* сравнение строк - слов 
* надо помнить что при сравнении мальенькая буква больше чем большая 
пример : */
console.log(`Сравнение строк`)
console.log('Абвг'>'абвг');
console.log('Никита'>'Егор');


// в JS существует много способов получение части строки но достаточно основного метода SLICE (start , end ) 
console.log(lengt.slice(22,29)); // указываем из какого диапазона позиций на нужно получить часть строки 
console.log(lengt.slice());//указываем если нам нужно получить часть строки/ весь диапозон из переменной 









///////////////////////////////////////////////////////////////////////////////////////////////////////////
/*                                           МАССИВЫ                                                    */
//создать массивы можно 2 способами
//1 способ 
let arr = new Array ();
//или же 
let arrs = [
    
    "1",
    '2', 
    '3', //как и в объктах указываем висячую запятую 

]; //что гораздо удобнее 

//в массивах может встречаться совсем разные типы данных 
let fmas = [
    '1',
    '6', 
    {
        array:2,
        jj:6,
        
    },
    true,
    function (){
        console.log((1.5))
    }
    

];
//так же сущетвует многомерные массивы 
let mngmas =[
    [1,2,3],
    [4,5,6],
    [7,8,9],
];

//что бы получить данные из массива нам нужно обратиться к позиции которая нас интересует , начинаются позиции с 0
console.log(mngmas[0]);

/*
let fmas = [
    '1',
    '6', 
    {
        array:2,
        jj:6,
        
    },
    true,
    function fun(){
        console.log(fun(1.5))
    }
    

];  */
//если я хочу обратиться например к объекту в данном массиве то следует делать следующем образом 
console.log(fmas[2].array) //в данном случае получаем данные только из array в объекте ;


//если я хочу вывести в лог данные функции ну или либо что она выводит / возвращает то следующем образом 
fmas[4]() //console.log когда мы хотим отобразить данные функции в массиве писать не нужно иначе буедт критическая ошибка 

//////////
/* что бы обратиться к конкретному елементу и его позиции в многомерном массиве в логе должен прописать*/
console.log(mngmas[2][2]);//где 1 - это позиция элемента-строка // а 2 это ключ и позиция  того элемента к которому я обратился 


/////////////////////////////////
//отличием массивов от объектов еще является то что в массивах есть свойство lenght
//что бы сразу получить длину массива и вывести его в отдельное значение надо прописать : 
console.log(mngmas.length);

///////////
function mnglen(){
    return mngmas.length;
};

console.log(`Длинна массива mngmas состовляет ${mnglen()} строки в многомерном исполнении`);
///////////
/* не забываем что массив являеться объектом соотвестнвенно и ведет себя так же */
//массив точног так же можно копировать и делегировать / все то же самое что и объектов
//при копирование массива можно изменять его длинну 
let newMng = mngmas ;
newMng.length = 1;
console.log(newMng);//напоминание что при копирование мы как бы просто создаем еще один ключ но все изменения так же будут внесены и в старый массив 
                    //а при делегировании мы иммено создаем новый массив / объект с такими же данными  но не как не связанами друг с другом  ;


                    ///last time 5:27 

/*
function last(){
    console.log("last time 5:27");
};
setInterval(last ,1000);*/

//если мы в массиве хотим изменить элемент иил добавить новый то делаем следущее

//если хотим изменить то просто выбераем позицию элемента который хотим изменить и присваеваем новое значение 
const massiv = ['Nikolya' , 'Egor' , 'Nikita',]; //определили массив 

//меняем элемент 
massiv [0] = 'Nikolay';
console.log(massiv);


//добавляем элемент - должны создать не сущетсвующую позицию которая не занята и написать элемент
massiv[3] = 'new Object in Massive';
console.log(massiv);




///// у масивов есть несколько методов которыек помогают добавлять переменные / удалять / ставить в начало очереди / или же в конец 

//метод push добавление перемнной в конец очереди 
const yrt=['1','2','3',];
yrt.push('добавление 4 элемента');//элемент добавляется с помощью метода в конец массива 
console.log(yrt);


//метод shift - удаляет элемент в начале , и освобождает очередь 2 элементу, который соответственно после удаления встанет на место первого и будет первым в массиве 
yrt.shift();
console.log(yrt);

//  метод pop - удаляет элемент в конце массива ;
yrt.pop();
console.log(yrt);

//метод unshift - добавляет элементы / элементы в начало массива , сдвигая уже сущесвующие назад / в конец очереди

yrt.unshift('123','234',);
console.log(yrt);









//// !!! методы push,pop работают быстро / а shift & unshift медленно 
///метод delete не очень хорош  при  удалении элемента , так как оставлят место элемента - просто удаляет название/текст/информацию которую в себе несла переменная 








///по этому есть более удобный метод splice { первое значение это позиция элемента , 2 значение количесвое изменяемых/удаляемых и тд элеметов }
yrt.splice(0,2);
console.log(yrt);

//что бы переменная обратно появилась нужно содать для нее новую переменную 
const ytr=['1','2','3',];
const removed = ytr.splice(0,2);  //непонимаю зачем нам это надо 
console.log(removed);

///заменяем элементы
const ytr1=['1','2','3',]; 
ytr1.splice(0,1, '7',);//как бы перезаписываем элемент
console.log(ytr1);

// добавляем позиции а массив например с 1 позиции 
const ytr2=['1','2','3',];
ytr2.splice(1,0, 'сумма чисел 6'); // 1 означаем что перед 1 элементом будут добавлены новые позиции а 
                                    //0 должен быть в данном случае обязателным так как если будет не 0 позиции просто удаляться 
console.log(ytr2);


//удаляем определенные элементы 
const ytr3=['1','2','3',];
ytr3.splice(-1,1); // удаляем в конце 
console.log(ytr3);


/////////////////  что бы копировать массив применяем свойство slice ( не предыдущее splice) 
//синтаксис таков  что мы выбераем позицию элемента и конечную точку до куда хотим скопировать(делегировать массив)
//при этом копируется все элементы не включая последний ( будет так если мы копируем определенную часть массива)
const masiveNumber=['1','2','3','4',];
const masNumb /* так же мы должны создать новую переменну */ = masiveNumber.slice(0,3); // 1 , 2, 3,
console.log(masNumb);

//если хотим копировать с конца то просто указываем значения со знаком - 


//что бы копировать вeсь массив указывваем slise без значений 
const masiNumb=['1','2','3','4','5',];
const ciCd = masiNumb.slice();
console.log(ciCd);

//Метод cancat - создаетр новый массив и копирует данные из старого , при этом в данный новый массив можно будет добавить данные 
const hhru=[ 5,'ничего себе'];
const ruhh = hhru.concat('Меня пригласили на собес))');
console.log(ruhh);  







//////////////////////// Поиск данных в массиве схож с поисоком данных в строках , те же самые методы indexOf / includes / lastIndexOf / startIndexOf
console.log(`Вспоминаем методы indexOf / includes из урока строк`)
const arwr =['Никита' ,' Саша' , 'Ваня' , 'Егор'];
console.log(arwr.indexOf('Никита'));                ////////////// indexOf покажет позицию на где находиться элемент 
console.log(arwr.indexOf('Егор'));
console.log(arwr.indexOf('Ярослав')); //-1 так как значения нет 


console.log(arwr.includes('Никита'));//includes показывает true false ест или нет такой позиции в массиве
console.log(arwr.includes('Никита' , 5 /*указываем позицию*/));


///поиск объектов в массиве { fidelity:1 , or:'2' , ltd.}
//методы find / findIndex
const iran = [
    {rocket: 200 , date:'01 october 2024 years'},
    {israel : "maksim galkin", rocket:150, vozrast : 55,},
]

// 1 нужно создать новую константу = после обращаемся к обьекту.find( и внутри прописываю функкцию которая будет возвращать объект с подходящими условиями )
//внутри самой функции прописываю переменные (item ,index,array) где item - сам объект / idex - позиция объекта / array - ключ объекта - его значения ;




/*const newIran = iran.find(function(item,index,arrayKey){
    return item.rocket===200;
});
console.log(newIran);*/

//перепишем в стрелочную функцию 
const newIran = iran.find((item) =>item.rocket === 200);
console.log(newIran);


////////!!!!!!!! FIND - ВОЗВРАЩАЕТ САМ ОБЪКЕТ И ЕГО ЗНАЧЕНИЯ / FINDINDEX - САМ ИНДЕКС - РАСПОЛОЖЕНИЕ ОБЪЕКТА 
const newIrans = iran.findIndex((item) =>item.rocket === 200);
console.log(newIrans);

////метод filter делает можно сказать тоже самое что и find только фильтр ищет все значения кторые подходят по условиям  среди массивов
//и полностью выводит массив удволетворяющий условия 
const newIranss = iran.filter((item) =>item.rocket >= 100);
console.log(newIranss);





//сотрировка массивов 
//метод sort( )

//если мы при помоши этого метода будем сравнивать строки / строчные значения то у нас все будет в порядке 
const abc = [
    a ='w',
    b = 'a',
    c ='c',

];
console.log(abc.sort());


//но если мы захотим сравнить числа то у нас возникнет ошибка так как sort даже числа будет сравнивать в строковом порядке 

const gh111=[ dfgf = 1 , frfrf = 8, fhf = 23,]; // неправильная сортировка 1  23  8 


//для того что бы у нас все было верно нам нужно прописать собственную функцию 
function sortNum(a,b){
    return a-b //вернет результат вычеслений / самый простой способ нормализовать сортировку 
    //можно конечно расписать все это но это не очень то и нужно 
    /* if (a>b) return 1 - положительное число 
    if(a==b) retutn 0
    if (a<b) - отрицательное число*/

};

//так же можно сделать совсем все просто и в методе sort( все что нужно сделать расписать )
console.log(gh111.sort((a,b) => a-b));

//так же есть метод сортировки revers он просто переворачивает сортироку , например от большего к меньшему 



//метод .map - вызывает функцию для каждого элемента маасива и возвращает какой то результат ( возварщает новый массив с результатами выполненых функций)
const mapss =[ valueMaps = 'dfsf' , couaps = 'irakss', ert = '17.455 234.32.32',];

const newMap = mapss.map (function(item,index,array){ // данная функция возвращает первый символ каждого значения объекта
    return item[0];
}); //стрелочная функция данного примера const newMap = mapss.map(item => item[0]);

console.log(newMap) // создается новый массив с даннфми из функции ;










//преобразование с помощью методов split / join
//split - преобразует строку в массив по заранее заданым разделителям 
const spl = 'Жил,Был,Иван,harry = 106,';
const newSpl = spl.split(',',3);//создание массива и его определенние по разделителям , а тк же указание сколько переменных попадет в масссив 
                                //(метод join наоборот преобразовываеть массив в строку но прописывается все точно так же как и при split) ---
                                //--- join - или же просто перевести данные из массива с помощью указания типа данных String
console.log(newSpl);





//так как массивы и объеты по типу данных это одно и то же то как нам узнать что из них массив а что объект ?
//в таком случае мы должны узнать это через функцию (Array.isArray...)
if (Array.isArray(spl)){
    console.log('Это массив');

} else {
    console.log('Ошибка, это не массив');
};




