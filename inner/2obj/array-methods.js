mas1 = ["первый", "второй", "третий", "четвыртый"];
mas1.push("пятый"); //метод push положит данную переменную в конец массива
console.log(mas1);

mas1.unshift("нулевой"); //метод unshift положит элемент в начало массива , и сдвинит все элементы на 1 позицию назад
console.log(mas1);

//метод shift - удаляет первый элемент из массива - но он не удаляется от просто извлекает его ,индекс все так же храниться
// метод POP работает ровно наоборот shift

//метод toReversev будет переворачивать и делать дубликат не копию! массива , метод reverse будт именно переаписывать оригинал

// точно так же по примерам выше у нас работают методы sort - перезаписывает искомый массив
// toSorted - делает дубликат и там удже производит изминения

const ggHLF = mas1.map(function (name, index) {
  //принимает в себя 2 параметра некую переменную и ее индекс
  //в методе map мы описывает логику как данная функция будет работать с каждым элементом массива
  if (index == 2) {
    return name.toUpperCase(); //перевили переменную по индексу
  } else {
    return name; // остальные просто вернули и ничего у них не изменили
  }
});
console.log(ggHLF); //то есть метод рабоатет как цикл и итерируется по каждому элементу и исполняет функцию

//includes - возвращает true / false и просто проверяет элемент на существование элемента в массиве
console.log(mas1.includes("седьмой"));
console.log(mas1.includes("второй"));

//практика - примеры посложнее
const bigMas = [
  { content: "первый", type: 1 },
  { content: "второй", type: 2 },
  { content: "четвыртый", type: 4 },
];

//например мы хотим найти определенный элемент с параметром type который будет равен 4
// можем использовать for of ...
// let threedCollection;
// for (let winner of bigMas) {
//   if (winner.type == 4) {
//     threedCollection = winner;
//   }
// }
// console.log(threedCollection);

//но для таких действий - функций лучше использовать метод find

const secondCollection = bigMas.find(function (position) {
  return position.type == 2;
  //   if (position.type == 2) {
  //     return true;
  //   }
});

console.log(secondCollection);
//так же по аналогии есть метод findIndex который уже будет возвращать не сам элемент а его индекс

//метод filter - будет фильтровать массив по определенным данным которые мы зададим например в данном случае у кого тип < 4
const otFiltr = bigMas.filter(function (mal) {
  return mal.type < 4;
});
console.log(otFiltr);

//так же мы можем написать более сложную функцию которая нам бдет сумировать все типы даных - их значение и выводить общее значение
const summTypes = bigMas
  .filter((p) => p.type > 1) //1 фильтруем масиив а именно значения равные > 1
  .map((p) => p.type) //дальше массив с объектами превращаем в значения 
  .reduce((acc, p) => acc + p, 0); //c момощью reduce заканчиваем вычисления // есть аккумулятор который на каждой итерации в себе будет 
  // сохранять предыдущее сложенно в данном слчае значение и складывать новое которое есть , 0 - это начальное значение 
console.log(summTypes);
//но проще все переписать с помошью forEach ( )

